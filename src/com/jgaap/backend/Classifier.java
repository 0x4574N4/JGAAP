package com.jgaap.backend;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.apache.log4j.Logger;

import com.jgaap.generics.AnalysisDriver;
import com.jgaap.generics.Canonicizer;
import com.jgaap.generics.EventCuller;
import com.jgaap.generics.EventDriver;
import com.jgaap.util.Document;
import com.jgaap.util.EventSet;

/**
 * Trainable pipeline to process and analyze documents
 * 
 * @author Michael Ryan
 * 
 */
public class Classifier {

	private List<EventDriver> eventDrivers;
	private AnalysisDriver analysisDriver;

	private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
	private static Logger logger = Logger.getLogger(Classifier.class);

	private Classifier(List<EventDriver> eventDrivers, AnalysisDriver analysisDriver) {
		this.eventDrivers = eventDrivers;
		this.analysisDriver = analysisDriver;
	}

	/**
	 * Analyze a Document Loads, Canonicizes, Eventifies, Culls, and Analyzes a
	 * single Document
	 * 
	 * @param document
	 *            the Document to be analyzed
	 * @return Document after results have been added.
	 */
	public Callable<Document> analyze(Document document) {
		return new Analyzer(document, eventDrivers, analysisDriver);
	}

	/**
	 * Analyze a Document Assumes Document has already been processed and only
	 * analyzes
	 * 
	 * @param document
	 *            the Document to be analyzed
	 * @return Document after results have been added
	 */
	public Callable<Document> analyzeKnown(Document document) {
		return new KnownAnalyser(document, analysisDriver);
	}

	public static class Builder {
		private List<EventDriver> eventDrivers;
		private AnalysisDriver analysisDriver;

		public Builder() {
			eventDrivers = new ArrayList<EventDriver>();
		}

		public Builder addEventDriver(EventDriver eventDriver) {
			eventDrivers.add(eventDriver);
			return this;
		}

		public Builder setAnalysisDriver(AnalysisDriver analysisDriver) {
			this.analysisDriver = analysisDriver;
			return this;
		}

		/**
		 * Analyze a Document Loads, Canonicizes, Eventifies, Culls, and Analyzes a
		 * single Document
		 * 
		 * @param document
		 *            the Document to be analyzed
		 * @return Document after results have been added.
		 */
		public Classifier build(List<Document> documents) throws Exception {
			ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
			// Process Documents in
			List<Future<Document>> futureDocuments = new ArrayList<Future<Document>>(documents.size());
			for (Document document : documents) {
				futureDocuments.add(executor.submit(new Processor(document)));
			}
			List<Future<Document>> futureEvents = new ArrayList<Future<Document>>(documents.size() * eventDrivers.size());
			// wait for loading/canonicizing to finish
			// build list of running EventDriver-Document pairs
			while (futureDocuments.size() != 0) {
				Iterator<Future<Document>> iterator = futureDocuments.iterator();
				while (iterator.hasNext()) {
					Future<Document> futureDocument = iterator.next();
					if (futureDocument.isDone()) {
						Document document = futureDocument.get();
						logger.info("Processing completed on Document " + document.toString());
						for (EventDriver eventDriver : eventDrivers) {
							futureEvents.add(executor.submit(new Eventifyer(document, eventDriver)));
						}
						iterator.remove();
					}
				}
			}

			// Wait for EventDrivers to finish
			while (futureEvents.size() != 0) {
				Iterator<Future<Document>> iterator = futureEvents.iterator();
				while (iterator.hasNext()) {
					Future<Document> futureDocument = iterator.next();
					if (futureDocument.isDone()) {
						Document document = futureDocument.get();
						logger.info("Finished eventifying " + document.toString());
						iterator.remove();
					}
				}
			}

			// Train Cullers of generated events
			List<Future<EventDriver>> futureEventDrivers = new ArrayList<Future<EventDriver>>(eventDrivers.size());
			for (EventDriver eventDriver : eventDrivers) {
				futureEventDrivers.add(executor.submit(new ReduceTrain(eventDriver, documents)));
			}

			List<Future<Document>> futureCulledDocuments = new ArrayList<Future<Document>>(documents.size() * eventDrivers.size());

			// Wait for Cullers to train, after they are trained launch Culling
			// of
			// EventSets
			while (futureEventDrivers.size() != 0) {
				Iterator<Future<EventDriver>> iterator = futureEventDrivers.iterator();
				while (iterator.hasNext()) {
					Future<EventDriver> futureEventDriver = iterator.next();
					if (futureEventDriver.isDone()) {
						EventDriver eventDriver = futureEventDriver.get();
						logger.info("Trained Cullers for events generated by " + eventDriver.displayName());
						for (Document document : documents) {
							futureCulledDocuments.add(executor.submit(new Reducer(document, eventDriver)));
						}
						iterator.remove();
					}
				}
			}

			// Wait for Culling to finish
			while (futureCulledDocuments.size() != 0) {
				Iterator<Future<Document>> iterator = futureCulledDocuments.iterator();
				while (iterator.hasNext()) {
					Future<Document> futureDocument = iterator.next();
					if (futureDocument.isDone()) {
						Document document = futureDocument.get();
						logger.info(document.toString() + " Culled");
						iterator.remove();
					}
				}
			}

			// Train AnalysisDriver
			logger.info("Starting Training " + analysisDriver.displayName());
			analysisDriver.train(documents);
			logger.info("Finish Training " + analysisDriver.displayName());
			return new Classifier(eventDrivers, analysisDriver);
		}
	}

	/**
	 * Loads a Document and porocesses any Canonicizers on it.
	 * 
	 * @author Michael Ryan
	 * 
	 */
	private static class Processor implements Callable<Document> {
		private Document document;

		Processor(Document document) {
			this.document = document;
		}

		@Override
		public Document call() throws Exception {
			document.load();
			document.processCanonicizers();
			return document;
		}
	}

	/**
	 * Generates a EventSet from a Document For use with Known Documents
	 * 
	 * @author Michael Ryan
	 * 
	 */
	private static class Eventifyer implements Callable<Document> {
		private Document document;
		private EventDriver eventDriver;

		Eventifyer(Document document, EventDriver eventDriver) {
			this.document = document;
			this.eventDriver = eventDriver;
		}

		@Override
		public Document call() throws Exception {
			char[] text = document.getText();
			for (Canonicizer canonicizer : eventDriver.getCanonicizers()) {
				text = canonicizer.process(text);
			}
			document.addEventSet(eventDriver, eventDriver.createEventSet(text));
			return document;
		}
	}

	/**
	 * Generates and Culls a EventSet from a Document For use with Unknown
	 * Documents
	 * 
	 * @author Michael Ryan
	 * 
	 */
	private static class UnknownEventifyer implements Callable<EventDriver> {
		private Document document;
		private EventDriver eventDriver;

		UnknownEventifyer(Document document, EventDriver eventDriver) {
			this.document = document;
			this.eventDriver = eventDriver;
		}

		@Override
		public EventDriver call() throws Exception {
			char[] text = document.getText();
			for (Canonicizer canonicizer : eventDriver.getCanonicizers()) {
				text = canonicizer.process(text);
			}
			EventSet eventSet = eventDriver.createEventSet(text);
			for (EventCuller culler : eventDriver.getEventCullers()) {
				eventSet = culler.cull(eventSet);
			}
			document.addEventSet(eventDriver, eventSet);
			return eventDriver;
		}
	}

	/**
	 * Trains all Cullers for a single EventDriver
	 * 
	 * @author Michael Ryan
	 * 
	 */
	private static class ReduceTrain implements Callable<EventDriver> {
		private EventDriver eventDriver;
		private List<Document> documents;

		ReduceTrain(EventDriver eventDriver, List<Document> documents) {
			this.eventDriver = eventDriver;
			this.documents = documents;
		}

		@Override
		public EventDriver call() throws Exception {
			List<EventSet> eventSets = new ArrayList<EventSet>(documents.size());
			for (Document document : documents) {
				eventSets.add(document.getEventSet(eventDriver));
			}
			for (EventCuller culler : eventDriver.getEventCullers()) {
				culler.init(eventSets);
			}
			return eventDriver;
		}
	}

	/**
	 * Culls EventSets generated by the EventDriver on the Document
	 * 
	 * @author Micahel Ryan
	 * 
	 */
	private static class Reducer implements Callable<Document> {
		private Document document;
		private EventDriver eventDriver;

		Reducer(Document document, EventDriver eventDriver) {
			this.document = document;
			this.eventDriver = eventDriver;
		}

		@Override
		public Document call() throws Exception {
			EventSet eventSet = document.getEventSet(eventDriver);
			for (EventCuller eventCuller : eventDriver.getEventCullers()) {
				eventSet = eventCuller.cull(eventSet);
			}
			document.addEventSet(eventDriver, eventSet);
			return document;
		}

	}

	/**
	 * Loads Canonicizes Eventify and Culls a Document to produces EventSets
	 * Analyzes the Document against the built analysisDriver
	 * 
	 * @author Michael Ryan
	 * 
	 */
	private static class Analyzer implements Callable<Document> {
		private Document document;
		private List<EventDriver> eventDrivers;
		private AnalysisDriver analysisDriver;

		Analyzer(Document document, List<EventDriver> eventDrivers, AnalysisDriver analysisDriver) {
			this.document = document;
			this.eventDrivers = eventDrivers;
			this.analysisDriver = analysisDriver;
		}

		@Override
		public Document call() throws Exception {
			document.load();
			document.processCanonicizers();
			for (EventDriver eventDriver : eventDrivers) {
				executor.submit(new UnknownEventifyer(document, eventDriver));
			}
			document.addResult(analysisDriver, analysisDriver.analyze(document));
			return document;
		}
	}

	/**
	 * Analyzes the Document against the built AnalyssDriver Assumes the
	 * Document's EventSets have been generated
	 * 
	 * @author Michael Ryan
	 * 
	 */
	private static class KnownAnalyser implements Callable<Document> {
		private Document document;
		private AnalysisDriver analysisDriver;

		KnownAnalyser(Document document, AnalysisDriver analysisDriver) {
			this.document = document;
			this.analysisDriver = analysisDriver;
		}

		@Override
		public Document call() throws Exception {
			document.addResult(analysisDriver, analysisDriver.analyze(document));
			return document;
		}
	}

}
